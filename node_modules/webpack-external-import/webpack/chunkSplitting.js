"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasExternalizedModule = hasExternalizedModule;
exports.interleaveConfig = interleaveConfig;

function hasExternalizedModule(module) {
  var _module$originalSourc, _module$originalSourc2, _module$originalSourc3;

  // check original module source
  var moduleSource = (module === null || module === void 0 ? void 0 : (_module$originalSourc = module.originalSource) === null || _module$originalSourc === void 0 ? void 0 : (_module$originalSourc2 = _module$originalSourc.call(module)) === null || _module$originalSourc2 === void 0 ? void 0 : (_module$originalSourc3 = _module$originalSourc2.source) === null || _module$originalSourc3 === void 0 ? void 0 : _module$originalSourc3.call(_module$originalSourc2)) || ""; // check if module contains magic comment

  if ((moduleSource === null || moduleSource === void 0 ? void 0 : moduleSource.indexOf("externalize")) > -1) {
    return moduleSource;
  }

  return false;
}

function interleaveConfig(_test) {
  return {
    test: function test(module) {
      // check if module has a resource path (not virtual modules)
      if (module.resource) {
        return module.resource.includes(_test) && !!hasExternalizedModule(module);
      }
    },
    // eslint-disable-next-line no-unused-vars
    name: function name(module, chunks, cacheGroupKey) {
      // Check if module is externalized
      var moduleSource = hasExternalizedModule(module);

      if (moduleSource) {
        // get externalize name from module source
        return moduleSource.match(/\/\*\s*externalize\s*:\s*(\S+)\s*\*\//)[1];
      }
    },
    // force module into a chunk regardless of how its used
    enforce: true // might need for next.js
    // reuseExistingChunk: false,

  };
}